<!-- TUC Computer Graphics Course Sandbox -->

</script><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>PacMan3D</title>
<link rel="icon" sizes="128x128" type="image" href="./media/img/pacman.ico" />
<!-- external libraries for matrix calculations and maintenance -->
<script type="text/javascript" src="./sandbox_files/glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="./sandbox_files/webgl-utils.js"></script>

<!-- Code for the vertex shader-->
<script id="shader-vs" type="x-shader/x-vertex">
//attributes for the vertex shader (different for every thread/core that will execute a copy of this)
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;

	//ModelView and Projection Matrices
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

	//Variable to be forwarded to the corresponding thread of the fragment shader
    varying vec4 vColor;

	//main function of the vertex shader
	//this code will be copied to many shader cores/threads and executed with the associated
	//data for every vertex (matrices, color, etc)
    void main(void) {
	
	//Each vertex is multiplied with the ModelView and Projection matrices and created a fragment
	    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		//Its color is forwarded to the fragment shader
        vColor = aVertexColor;
    }
</script>

<!-- Code for the fragment shader-->
<script id="shader-fs" type="x-shader/x-fragment">
    //necessary code for compatibility
	precision mediump float;

	//Variable coming from the vertex shader
    varying vec4 vColor;

    void main(void) {
	//the fragment gets its color value.
	//in the fragment shader many advanced shading algorithms can be implemented (Phong etc..)
        gl_FragColor = vColor;
    }
</script>

<!-- Javascript code for the main functionality of the WebGL application-->
<script type="text/javascript">
	//the variable that will accommodate the WebGL context
	//every call to the state machine will be done through this variable
    var gl;    

	//Initialize WebGL
    function initGL(canvas) {
        try {
		//get a webgl context
            gl = canvas.getContext("experimental-webgl");
			//assign a viewport width and height based on the HTML canvas element properties
			//(check last lines of code)
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
			//any error is handled here
			//all errors are visible in the console (F12 in Google chrome)
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }


	//Find and compile shaders (vertex + fragment shader)
    function getShader(gl, id) {
	//gets the shader scripts (vertex + fragment)
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
		//create shaders
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

		//ask WebGL to compile shaders
		//we check for errors here too
		//all errors are visible in the console (F12 in Google chrome)
        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }


	
    var shaderProgram;

	//Creates a program from a vertex + fragment shader pair
    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
		//link the compiled binaries
        gl.linkProgram(shaderProgram);

		//check for errors, again
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

		//activate current program
		//this sandbox has only on shader pair
		//we can have as many as we wish in more complex applications
        gl.useProgram(shaderProgram);

		//Update attributes for the vertex shader
		//attributes are accessible only from the vertex shader
		//if we want accessible data from a fragment shader we can use uniform variables,
		//or varyings that will be forwarded from the vertex shader to the fragment shader
		
		//Vertex position data
        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

		//Vertex color data
        shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
        gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);

		//Update uniform variables
		//this variables can be accessed from both the vertex and fragment shader
        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
    }


	//ModelView and Projection matrices
	//mat4 comes from the external library
    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();

	//The matrix stack operation are implemented below to handle local transformations
	
	//Push Matrix Operation
    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

	//Pop Matrix Operation
    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }


	//Sets + Updates matrix uniforms
    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    }


	//Rotation function helper
	function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }


	//Vertex, Index and Color Data
    var cubeVertexPositionBuffer; // contains coordinates
    var cubeVertexColorBuffer; //contains color per vertex
    var cubeVertexIndexBuffer; //contains indices for chains of vertices to draw triangles/other geometry

	//Initialize VBOs, IBOs and color
    function initBuffers() {
        //Vertex Buffer Object
        cubeVertexPositionBuffer = gl.createBuffer();
		//Bind buffer to ARRAY_BUFFER
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        vertices = [
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
		//every item has 3 coordinates (x,y,z)
        cubeVertexPositionBuffer.itemSize = 3;
		//we have 24 vertices
        cubeVertexPositionBuffer.numItems = 24;

		//ColorWall
        cubeVertexColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
        colors = [
            [0.0, 0.5, 1.0, 1.0], // Front face
            [0.0, 0.0, 1.0, 1.0], // Back face
            [0.0, 0.0, 1.0, 1.0], // Top face
            [0.0, 0.0, 1.0, 1.0], // Bottom face
            [0.0, 0.5, 1.0, 1.0], // Right face
            [0.0, 0.5, 1.0, 1.0]  // Left face
        ];
        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
			//assign colors for each vertex of each face based on the packed representation above
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
		//every color has 4 values: red, green, blue and alpha (transparency: use 1.0 (opaque) for this demo)
        cubeVertexColorBuffer.itemSize = 4;
		//24 color values (we have 24 vertices to color...)
        cubeVertexColorBuffer.numItems = 24;
		
		//ColorPlane
        cubeVertexColorBufferPlane = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBufferPlane);
        colors = [
            [0.0, 1.0, 0.0, 1.0], // Front face
            [0.0, 1.0, 0.0, 1.0], // Back face
            [0.0, 1.0, 0.0, 1.0], // Top face
            [0.0, 1.0, 0.0, 1.0], // Bottom face
            [0.0, 1.0, 0.0, 1.0], // Right face
            [0.0, 1.0, 0.0, 1.0]  // Left face
        ];
        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
			//assign colors for each vertex of each face based on the packed representation above
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
		//every color has 4 values: red, green, blue and alpha (transparency: use 1.0 (opaque) for this demo)
        cubeVertexColorBufferPlane.itemSize = 4;
		//24 color values (we have 24 vertices to color...)
        cubeVertexColorBufferPlane.numItems = 24;
		
		//ColorPoint
        cubeVertexColorBufferPoint = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBufferPoint);
        colors = [
            [1.0, 0.5, 0.0, 1.0], // Front face
            [1.0, 0.5, 0.0, 1.0], // Back face
            [1.0, 0.5, 0.0, 1.0], // Top face
            [1.0, 0.5, 0.0, 1.0], // Bottom face
            [1.0, 0.5, 0.0, 1.0], // Right face
            [1.0, 0.5, 0.0, 1.0]  // Left face
        ];
        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
			//assign colors for each vertex of each face based on the packed representation above
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
		//every color has 4 values: red, green, blue and alpha (transparency: use 1.0 (opaque) for this demo)
        cubeVertexColorBufferPoint.itemSize = 4;
		//24 color values (we have 24 vertices to color...)
        cubeVertexColorBufferPoint.numItems = 24;
		
		//ColorPacman
        cubeVertexColorBufferPacman = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBufferPacman);
        colors = [
            [1.0, 1.0, 0.0, 1.0], // Front face
            [1.0, 1.0, 0.0, 1.0], // Back face
            [1.0, 1.0, 0.0, 1.0], // Top face
            [1.0, 1.0, 0.0, 1.0], // Bottom face
            [1.0, 1.0, 0.0, 1.0], // Right face
            [1.0, 1.0, 0.0, 1.0]  // Left face
        ];
        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
			//assign colors for each vertex of each face based on the packed representation above
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
		//every color has 4 values: red, green, blue and alpha (transparency: use 1.0 (opaque) for this demo)
        cubeVertexColorBufferPacman.itemSize = 4;
		//24 color values (we have 24 vertices to color...)
        cubeVertexColorBufferPacman.numItems = 24;
		
		//Color_Ghost_1
        cubeVertexColorBufferGhost1 = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBufferGhost1);
        colors = [
            [1.0, 0.0, 0.0, 1.0], // Front face
            [1.0, 0.0, 0.0, 1.0], // Back face
            [1.0, 0.0, 0.0, 1.0], // Top face
            [1.0, 0.0, 0.0, 1.0], // Bottom face
            [1.0, 0.0, 0.0, 1.0], // Right face
            [1.0, 0.0, 0.0, 1.0]  // Left face
        ];
        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
			//assign colors for each vertex of each face based on the packed representation above
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
		//every color has 4 values: red, green, blue and alpha (transparency: use 1.0 (opaque) for this demo)
        cubeVertexColorBufferGhost1.itemSize = 4;
		//24 color values (we have 24 vertices to color...)
        cubeVertexColorBufferGhost1.numItems = 24;
		
		//Color_Ghost_2
        cubeVertexColorBufferGhost2 = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBufferGhost2);
        colors = [
            [0.5, 0.0, 1.0, 1.0], // Front face
            [0.5, 0.0, 1.0, 1.0], // Back face
            [0.5, 0.0, 1.0, 1.0], // Top face
            [0.5, 0.0, 1.0, 1.0], // Bottom face
            [0.5, 0.0, 1.0, 1.0], // Right face
            [0.5, 0.0, 1.0, 1.0]  // Left face
        ];
        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
			//assign colors for each vertex of each face based on the packed representation above
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
		//every color has 4 values: red, green, blue and alpha (transparency: use 1.0 (opaque) for this demo)
        cubeVertexColorBufferGhost2.itemSize = 4;
		//24 color values (we have 24 vertices to color...)
        cubeVertexColorBufferGhost2.numItems = 24;
		
		
		//Color_Ghost_Black
        cubeVertexColorBufferGhostBlack = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBufferGhostBlack);
        colors = [
            [0.3, 0.3, 0.3, 1.0], // Front face
            [0.3, 0.3, 0.3, 1.0], // Back face
            [0.3, 0.3, 0.3, 1.0], // Top face
            [0.3, 0.3, 0.3, 1.0], // Bottom face
            [0.3, 0.3, 0.3, 1.0], // Right face
            [0.3, 0.3, 0.3, 1.0]  // Left face
        ];
        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
			//assign colors for each vertex of each face based on the packed representation above
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
		//every color has 4 values: red, green, blue and alpha (transparency: use 1.0 (opaque) for this demo)
        cubeVertexColorBufferGhostBlack.itemSize = 4;
		//24 color values (we have 24 vertices to color...)
        cubeVertexColorBufferGhostBlack.numItems = 24;

		//Index Buffer Object
		//it joins sets of vertices into faces
        cubeVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        var cubeVertexIndices = [
		//this numbers are positions in the VBO array above
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
        //we have one item - the cube
		cubeVertexIndexBuffer.itemSize = 1;
		//we have 36 indices (6 faces, every face has 2 triangles, each triangle 3 vertices: 2x3x6=36)
        cubeVertexIndexBuffer.numItems = 36;
    }

	//Helper Variables
    var rCube = 0;
	var swinging = 0.01;
	var movDirection = true;
	
	////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////
	///////////////////////////// METABLHTES ///////////////////////////////////
	var xTrans = 6.0;
	var yTrans = -5.0;
	
	var step = 0;
	
	var points = 0;
	var finished = 0;
	
	var camNo = 1;
	
	var ghost1Move = 1;
	var ghost1Step = 0;
	var ghost2Move = 2;
	var ghost2Step = 0;
	
	var pista = 1;
	
	var death = new Audio('./media/sounds/death.wav');
	var intro = new Audio('./media/sounds/intro.wav');
	var levelUp = new Audio('./media/sounds/levelUp.mp3');
	
	
	var remainingMoves = 0;
	var gameStatus = 0;
	
	var goLeft = 0;
	var goRight = 0;
	var goUp = 0;
	var goDown = 0;

	var wantLeft = 0;
	var wantRight = 0;
	var wantUp = 0;
	var wantDown = 0;
	
	var ghost_1_X = 10;
	var ghost_1_Y = -1;
	
	var ghost_2_X = 1;
	var ghost_2_Y = -9;
	
	
	
	var objType = [   
				  [1,1,1,1,1,1,1,1,1,1,1,1,1],
				  [1,3,2,2,2,2,2,2,2,2,2,3,1],
				  [1,2,1,1,2,1,1,1,2,1,1,2,1],
				  [1,2,2,2,2,2,2,2,2,2,2,2,1],
				  [1,1,2,1,1,1,1,1,1,1,2,1,1],
				  [2,2,2,2,2,2,0,2,2,2,2,2,2],
				  [1,1,2,1,2,1,1,1,2,1,2,1,1],
				  [1,2,2,1,2,2,2,2,2,1,2,2,1],
				  [1,2,1,1,1,2,1,2,1,1,1,2,1],
				  [1,3,2,2,2,2,1,2,2,2,2,3,1],
				  [1,1,1,1,1,1,1,1,1,1,1,1,1]
				  ];
				  
	////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////
	///////////////////////////// end METABLHTES ///////////////////////////////
	
	
	
	
	function initializeVariables() {
	
		xTrans = 6.0;
		yTrans = -5.0;
		step = 0;
		
		goLeft = 0;
		goRight = 0;
		goUp = 0;
		goDown = 0;
		wantLeft = 0;
		wantRight = 0;
		wantUp = 0;
		wantDown = 0;
		
		remainingMoves = 0;
		ghost_1_X = 10;
		ghost_1_Y = -1;
		ghost_2_X = 1;
		ghost_2_Y = -9;
		
		points = 0;
		finished = 0;
		
		objType = [   
				  [1,1,1,1,1,1,1,1,1,1,1,1,1],
				  [1,3,2,2,2,2,2,2,2,2,2,3,1],
				  [1,2,1,1,2,1,1,1,2,1,1,2,1],
				  [1,2,2,2,2,2,2,2,2,2,2,2,1],
				  [1,1,2,1,1,1,1,1,1,1,2,1,1],
				  [2,2,2,2,2,2,0,2,2,2,2,2,2],
				  [1,1,2,1,2,1,1,1,2,1,2,1,1],
				  [1,2,2,1,2,2,2,2,2,1,2,2,1],
				  [1,2,1,1,1,2,1,2,1,1,1,2,1],
				  [1,3,2,2,2,2,1,2,2,2,2,3,1],
				  [1,1,1,1,1,1,1,1,1,1,1,1,1]
				  ];
	}	
	
	function initializeVariables2() {
	
		xTrans = 6.0;
		yTrans = -5.0;
		step = 0;
		
		goLeft = 0;
		goRight = 0;
		goUp = 0;
		goDown = 0;
		wantLeft = 0;
		wantRight = 0;
		wantUp = 0;
		wantDown = 0;
		
		remainingMoves = 0;
		ghost_1_X = 10;
		ghost_1_Y = -1;
		ghost_2_X = 1;
		ghost_2_Y = -9;
		
		points = 0;
		finished = 0;
		
		objType = [   
				  [1,1,1,1,1,1,1,1,1,1,1,1,1],
				  [2,2,2,2,3,1,1,1,3,2,2,2,2],
				  [1,2,1,1,2,2,2,2,2,1,1,2,1],
				  [1,2,1,2,2,2,1,2,2,2,1,2,1],
				  [1,2,1,2,1,1,1,1,1,2,1,2,1],
				  [1,2,2,2,2,2,0,2,2,2,2,2,1],
				  [1,1,1,1,2,1,1,1,2,1,1,1,1],
				  [1,2,2,2,2,2,1,2,2,2,2,2,1],
				  [1,2,1,1,1,2,1,2,1,1,1,2,1],
				  [2,2,2,2,2,3,1,3,2,2,2,2,2],
				  [1,1,1,1,1,1,1,1,1,1,1,1,1]
				  ];
	}	
	
	
	
	//array for keeping pressed keys
	var currentlyPressedKeys = {};

	//Keyboard handler
	//do not touch :) 
    function handleKeyDown(event) {
        currentlyPressedKeys[event.keyCode] = true;

        if (String.fromCharCode(event.keyCode) == "F") {
            filter += 1;
            if (filter == 3) {
                filter = 0;
            }
        }
    }
	
	
	
	//Keyboard handler
	//do not touch :) 
    function handleKeyUp(event) {
        currentlyPressedKeys[event.keyCode] = false;
    }

	//Key pressed callback
	//37-40 are the codes for the arrow keys
	//xTrans + yTrans are used in the ModelView matrix for local transformation of the cube
    function handleKeys() {
		
		if (currentlyPressedKeys[32]) {
			// Space Bar key
			gameStatus = 1;
			
			document.getElementById("TUCWebGL").style.display="block";
			document.getElementById("WelcomeScreen").style.display="none";
			
        }
		
		if (currentlyPressedKeys[50]) {
			// 2 key
				camNo = 2;		
        }
		
		if (currentlyPressedKeys[49]) {
			// 1 key
				camNo = 1;		
        }
		
        if (currentlyPressedKeys[37]) {
			// Left cursor key
			
				//if (objType[-yTrans][xTrans-1] != 1)
				//{
					wantLeft = 1;
					ghost1Move = Math.floor(Math.random() * 4) + 1;
					ghost2Move = Math.floor(Math.random() * 4) + 1;
					wantRight = 0;
					wantUp = 0;
					wantDown = 0;	
				//}
			
        }
		
        if (currentlyPressedKeys[39]) {
            // Right cursor key
			
				//if (objType[-yTrans][xTrans+1] != 1)
				//{
					wantLeft = 0;
					wantRight = 1;
					ghost1Move = Math.floor(Math.random() * 4) + 1;
					ghost2Move = Math.floor(Math.random() * 4) + 1;
					wantUp = 0;
					wantDown = 0;
				//}
			
        }
		
        if (currentlyPressedKeys[38]) {
            // Up cursor key
			
				//if (objType[-yTrans-1][xTrans] != 1)
				//{
					wantLeft = 0;
					wantRight = 0;
					wantUp = 1;
					ghost1Move = Math.floor(Math.random() * 4) + 1;
					ghost2Move = Math.floor(Math.random() * 4) + 1;
					wantDown = 0;
				//}
			
        }
		
        if (currentlyPressedKeys[40]) {
            // Down cursor key
			
			
				//if (objType[-yTrans+1][xTrans] != 1)
				//{
					wantLeft = 0;
					wantRight = 0;
					wantUp = 0;
					wantDown = 1;
					ghost1Move = Math.floor(Math.random() * 4) + 1;
					ghost2Move = Math.floor(Math.random() * 4) + 1;
				//}
				
			
			
		}	
    }
	
	function want() {
		
		if (wantLeft == 1) 
		{
			if (objType[-yTrans][xTrans-1] != 1)
			{
				goLeft = 1;
				goRight = 0;
				goUp = 0;
				goDown = 0;
			}
		}
		else if (wantRight == 1) 
		{
			if (objType[-yTrans][xTrans+1] != 1)
			{
				goLeft = 0;
				goRight = 1;
				goUp = 0;
				goDown = 0;
			}
		}
		else if (wantUp == 1) 
		{
			if (objType[-yTrans-1][xTrans] != 1)
			{
				goLeft = 0;
				goRight = 0;
				goUp = 1;
				goDown = 0;
			}
		}
		else if (wantDown == 1) 
		{
			if (objType[-yTrans+1][xTrans] != 1)
			{
				goLeft = 0;
				goRight = 0;
				goUp = 0;
				goDown = 1;
			}
		}
		
	}
	
	function direction() 
	{
		if (goLeft == 1)
		{
			
			if (xTrans < 0.5)
			{
				xTrans = 12;
			}
			else
			{
				if (step == 0)
				{
					if (objType[-yTrans][xTrans-1] != 1)
					{
						if (remainingMoves > 0)
						{
							remainingMoves = remainingMoves - 1;
						}
						xTrans -= 1;
						step = 1;
					}
				}
				else if (step == 1)
				{
					//xTrans -= 1;
					step = 2;
					
				}
				else if (step == 2)
				{
					//xTrans -= 1;
					step = 3;
					
				}
				else if (step == 3)
				{
					//xTrans -= 1;
					step = 4;
				}
				else if (step == 4)
				{
					//xTrans -= 1;
					step = 0;
				}
			}
			
			
				// pairnei pontoys
				if (objType[-yTrans][xTrans] == 2)
				{
					objType[-yTrans][xTrans] = 0;
					
					
					points = points + 1;
				}
				// megala pellets
				else if (objType[-yTrans][xTrans] == 3)
				{
					objType[-yTrans][xTrans] = 0;
					remainingMoves = 35;
				}
				
				// telos pistas 
				else if (points == 63)
				{
					finished = 1;
				}
				
				// sygkroush me fantasma 1
				else if (xTrans==ghost_1_X && yTrans==ghost_1_Y)
				{
					
					if (remainingMoves > 0)
					{
						ghost_1_X = 6;
						ghost_1_Y = -5;
					}
					else 
					{
						finished = 2;
					}
				}
				// sygkroush me fantasma 2
				else if (xTrans==ghost_2_X && yTrans==ghost_2_Y)
				{
					if (remainingMoves > 0)
					{
						ghost_2_X = 6;
						ghost_2_Y = -5;
					}
					else 
					{
						finished = 2;
					}
				}
			
		}
		else if (goRight == 1)
		{
		
			if (xTrans > 11.5)
			{
				xTrans = 0;
			}
			else
			{
				if (step == 0)
				{
					if (objType[-yTrans][xTrans+1] != 1)
					{
						if (remainingMoves > 0)
						{
							remainingMoves = remainingMoves - 1;
						}
						xTrans += 1;
						step = 1;
					}
					
					
				}
				else if (step == 1)
				{
					//xTrans -= 1;
					step = 2;
					
				}
				else if (step == 2)
				{
					//xTrans -= 1;
					step = 3;
					
				}
				else if (step == 3)
				{
					//xTrans -= 1;
					step = 4;
				}
				else if (step == 4)
				{
					//xTrans -= 1;
					step = 0;
				}
			}
			
			
							if (objType[-yTrans][xTrans] == 2)
				{
					objType[-yTrans][xTrans] = 0;
					
					
					points = points + 1;
				}
				else if (objType[-yTrans][xTrans] == 3)
				{
					objType[-yTrans][xTrans] = 0;
					remainingMoves = 35;
				}
				else if (points == 63)
				{
					finished = 1;
				}
				else if (xTrans==ghost_1_X && yTrans==ghost_1_Y)
				{
					if (remainingMoves > 0)
					{
						ghost_1_X = 6;
						ghost_1_Y = -5;
					}
					else 
					{
						finished = 2;
					}
				}
				else if (xTrans==ghost_2_X && yTrans==ghost_2_Y)
				{
					if (remainingMoves > 0)
					{
						ghost_2_X = 6;
						ghost_2_Y = -5;
					}
					else 
					{
						finished = 2;
					}
				}
			
		}
		else if (goUp == 1)
		{
			
			if (step == 0)
			{
				if (objType[-yTrans-1][xTrans] != 1)
				{
					if (remainingMoves > 0)
					{
						remainingMoves = remainingMoves - 1;
					}
					yTrans += 1;
					
					step = 1;
				}
			}
			else if (step == 1)
			{
				//xTrans -= 1;
				step = 2;
				
			}
			else if (step == 2)
			{
				//xTrans -= 1;
				step = 3;
				
			}
			else if (step == 3)
			{
				//xTrans -= 1;
				step = 4;
			}
			else if (step == 4)
			{
				//xTrans -= 1;
				step = 0;
			}
			
			
			
				if (objType[-yTrans][xTrans] == 2)
				{
					objType[-yTrans][xTrans] = 0;
					
					
					points = points + 1;
				}
				else if (objType[-yTrans][xTrans] == 3)
				{
					objType[-yTrans][xTrans] = 0;
					remainingMoves = 35;
				}
				else if (points == 63)
				{
					finished = 1;
				}
				else if (xTrans==ghost_1_X && yTrans==ghost_1_Y)
				{
					if (remainingMoves > 0)
					{
						ghost_1_X = 6;
						ghost_1_Y = -5;
					}
					else 
					{
						finished = 2;
					}
				}
				else if (xTrans==ghost_2_X && yTrans==ghost_2_Y)
				{
					if (remainingMoves > 0)
					{
						ghost_2_X = 6;
						ghost_2_Y = -5;
					}
					else 
					{
						finished = 2;
					}
				}
			
		}
		else if (goDown == 1)
		{
			
			if (step == 0)
			{
				if (objType[-yTrans+1][xTrans] != 1)
				{
					if (remainingMoves > 0)
					{
						remainingMoves = remainingMoves - 1;
					}
					yTrans -= 1;
					
					step = 1;
				}
			}
			else if (step == 1)
			{
				//xTrans -= 1;
				step = 2;
				
			}
			else if (step == 2)
			{
				//xTrans -= 1;
				step = 3;
				
			}
			else if (step == 3)
			{
				//xTrans -= 1;
				step = 4;
			}
			else if (step == 4)
			{
				//xTrans -= 1;
				step = 0;
			}
			
			
			
				if (objType[-yTrans][xTrans] == 2)
				{
					objType[-yTrans][xTrans] = 0;
					points = points + 1;
				}
				else if (objType[-yTrans][xTrans] == 3)
				{
					objType[-yTrans][xTrans] = 0;
					remainingMoves = 35;
				}
				else if (points == 63)
				{
					finished = 1;
				}
				else if (xTrans==ghost_1_X && yTrans==ghost_1_Y)
				{
					if (remainingMoves > 0)
					{
						ghost_1_X = 6;
						ghost_1_Y = -5;
					}
					else 
					{
						finished = 2;
					}
				}
				else if (xTrans==ghost_2_X && yTrans==ghost_2_Y)
				{
					if (remainingMoves > 0)
					{
						ghost_2_X = 6;
						ghost_2_Y = -5;
					}
					else 
					{
						finished = 2;
					}
				}
			
			
        }
		
	}
	
	function moveGhost()
	{
		///////////////////////////////////////
		////////////  ghost 1   ///////////////
		///////////////////////////////////////
		
		//LEFT MOVE
		if (ghost1Move == 1)
		{
			if (ghost_1_X < 0.5)
			{
				ghost_1_X = 12;
			}
			else
			{
				if (ghost1Step == 0)
				{	
					
					
						if (objType[-ghost_1_Y][ghost_1_X-1] != 1)
						{
							ghost_1_X -= 1;
							ghost1Step = 1;
						}
						else 
						{
							ghost1Move = Math.floor(Math.random() * 4) + 1;
						}
					
					
				}
				else if (ghost1Step == 1)
				{
					//xTrans -= 1;
					ghost1Step = 2;
					
				}
				else if (ghost1Step == 2)
				{
					//xTrans -= 1;
					ghost1Step = 3;
					
				}
				else if (ghost1Step == 3)
				{
					//xTrans -= 1;
					ghost1Step = 0;
					
				}
			}
		}
		//RIGHT MOVE
		else if (ghost1Move == 2)
		{
			if (ghost_1_X > 11.5)
			{
				ghost_1_X = 0;
			}
			else
			{
				if (ghost1Step == 0)
				{	
					
						if (objType[-ghost_1_Y][ghost_1_X+1] != 1)
						{
							ghost_1_X += 1;
							ghost1Step = 1;
						}
						else 
						{
							ghost1Move = Math.floor(Math.random() * 4) + 1;
						}
					
					
				}
				else if (ghost1Step == 1)
				{
					//xTrans -= 1;
					ghost1Step = 2;
					
				}
				else if (ghost1Step == 2)
				{
					//xTrans -= 1;
					ghost1Step = 3;
					
				}
				else if (ghost1Step == 3)
				{
					//xTrans -= 1;
					ghost1Step = 0;
					
				}
			}
		}
		//UP MOVE
		else if (ghost1Move == 3)
		{
			if (ghost1Step == 0)
			{	
				
					if (objType[-ghost_1_Y-1][ghost_1_X] != 1)
					{
						ghost_1_Y += 1;
						ghost1Step = 1;
					}
					else 
					{
						ghost1Move = Math.floor(Math.random() * 4) + 1;
					}
				
				
			}
			else if (ghost1Step == 1)
			{
				//xTrans -= 1;
				ghost1Step = 2;
				
			}
			else if (ghost1Step == 2)
			{
				//xTrans -= 1;
				ghost1Step = 3;
				
			}
			else if (ghost1Step == 3)
			{
				//xTrans -= 1;
				ghost1Step = 0;
				
			}
		}
		// DOWN MOVE
		else if (ghost1Move == 4)
		{
			if (ghost1Step == 0)
			{	
				
					if (objType[-ghost_1_Y+1][ghost_1_X] != 1)
					{
						ghost_1_Y -= 1;
						ghost1Step = 1;
					}
					else 
					{
						ghost1Move = Math.floor(Math.random() * 4) + 1;
					}
				
				
			}
			else if (ghost1Step == 1)
			{
				//xTrans -= 1;
				ghost1Step = 2;
				
			}
			else if (ghost1Step == 2)
			{
				//xTrans -= 1;
				ghost1Step = 3;
				
			}
			else if (ghost1Step == 3)
			{
				//xTrans -= 1;
				ghost1Step = 0;
				
			}
		}
	
		///////////////////////////////////////
		////////////  ghost 2   ///////////////
		///////////////////////////////////////
		//LEFT MOVE
		if (ghost2Move == 1)
		{
			if (ghost_2_X < 0.5)
			{
				ghost_2_X = 12;
			}
			else
			{
				if (ghost2Step == 0)
				{	
					
					
						if (objType[-ghost_2_Y][ghost_2_X-1] != 1)
						{
							ghost_2_X -= 1;
							ghost2Step = 1;
						}
						else 
						{
							ghost2Move = Math.floor(Math.random() * 4) + 1;
						}
					
					
				}
				else if (ghost2Step == 1)
				{
					//xTrans -= 1;
					ghost2Step = 2;
					
				}
				else if (ghost2Step == 2)
				{
					//xTrans -= 1;
					ghost2Step = 3;
					
				}
				else if (ghost2Step == 3)
				{
					//xTrans -= 1;
					ghost2Step = 0;
					
				}
			}
		}
		//RIGHT MOVE
		else if (ghost2Move == 2)
		{
			if (ghost_2_X > 11.5)
			{
				ghost_2_X = 0;
			}
			else
			{
				if (ghost2Step == 0)
				{	
					
						if (objType[-ghost_2_Y][ghost_2_X+1] != 1)
						{
							ghost_2_X += 1;
							ghost2Step = 1;
						}
						else 
						{
							ghost2Move = Math.floor(Math.random() * 4) + 1;
						}
					
					
				}
				else if (ghost2Step == 1)
				{
					//xTrans -= 1;
					ghost2Step = 2;
					
				}
				else if (ghost2Step == 2)
				{
					//xTrans -= 1;
					ghost2Step = 3;
					
				}
				else if (ghost2Step == 3)
				{
					//xTrans -= 1;
					ghost2Step = 0;
					
				}
			}
		}
		//UP MOVE
		else if (ghost2Move == 3)
		{
			if (ghost2Step == 0)
			{	
				
					if (objType[-ghost_2_Y-1][ghost_2_X] != 1)
					{
						ghost_2_Y += 1;
						ghost2Step = 1;
					}
					else 
					{
						ghost2Move = Math.floor(Math.random() * 4) + 1;
					}
				
				
			}
			else if (ghost2Step == 1)
			{
				//xTrans -= 1;
				ghost2Step = 2;
				
			}
			else if (ghost2Step == 2)
			{
				//xTrans -= 1;
				ghost2Step = 3;
				
			}
			else if (ghost2Step == 3)
			{
				//xTrans -= 1;
				ghost2Step = 0;
				
			}
		}
		// DOWN MOVE
		else if (ghost2Move == 4)
		{
			if (ghost2Step == 0)
			{	
				
					if (objType[-ghost_2_Y+1][ghost_2_X] != 1)
					{
						ghost_2_Y -= 1;
						ghost2Step = 1;
					}
					else 
					{
						ghost2Move = Math.floor(Math.random() * 4) + 1;
					}
				
				
			}
			else if (ghost2Step == 1)
			{
				//xTrans -= 1;
				ghost2Step = 2;
				
			}
			else if (ghost2Step == 2)
			{
				//xTrans -= 1;
				ghost2Step = 3;
				
			}
			else if (ghost2Step == 3)
			{
				//xTrans -= 1;
				ghost2Step = 0;
				
			}
		}
	}
	function check(){
		
		if (finished == 1)
		{
			initializeVariables2();
			finished = 0;
			
			if (pista == 2) // termatismos paixnidiou!
			{
				webGLStart();
				document.getElementById("WinnerScreen").style.display="block";
				document.getElementById("TUCWebGL").style.display="none";
			}
			pista = 2;
			levelUp.play();
		}
		else if (finished == 2)
		{
			initializeVariables();
			death.play();
			
			
		}
		
	}
	//For every frame this function draws the complete scene from the beginning
    function drawScene() {
	//the viewport gets the canvas values (that were assigned to the gl context variable)
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
		//the frame and depth buffers get cleaned (the depth buffer is used for sorting fragments)
		//without the depth buffer WebGL does not know which fragment is visible for a given pixel
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

		//the projection matrix (pMatrix) is set
		//45 degrees Field-Of-View
		//aspect ratio gl.viewportWidth / gl.viewportHeight
		//near plane: 0.1 , far plane: 100
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

		//the modelview Matrix is initialized with the Identity Matrix
        mat4.identity(mvMatrix);
		
		///////////////////////////////////////////////////////////////////////////////////////
		///////////////////////   CAMERA    ///////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////
		//the ModelView matrix gets a global transformation ("camera" retracts 8 units)
		//otherwise the "camera" will be inside the rotating cube
		//z-axis points out of the screen. we translate -8 which is the inverse transform
		//in essence we move the world -8 units to have the camera 8 units forward.
		//REMEMBER there is no actual camera in WebGL
		
			if (camNo == 1)
			{
				mat4.translate(mvMatrix, [-12.0, 10.0, -35.0]);
				mat4.rotate(mvMatrix, degToRad(50), [1, 0, 0]);
			}
			else if (camNo == 2)
			{
				
				mat4.translate(mvMatrix, [-8.0, 3.0, -50.0]);
				mat4.rotate(mvMatrix, degToRad(-30), [0, 1, 0]);
				mat4.rotate(mvMatrix, degToRad(35), [1, 0, 0]);
			}
		
		
				
		///////////////////////////////////////////////////////////////////////////////////////
		///////////////////////   PAC-MAN    ///////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////
		
		//Keyboard controlled cube
		//we use the matrix stack to employ a local transformation to the cube
		mvPushMatrix();
     	//a translation associated with the keyboard
		mat4.translate(mvMatrix, [xTrans*2, 1, -yTrans*2]);
		/*********************************************/
		//BIND BUFFERS!!!!!!!!!!!!
		//MUST BE DONE ONCE BEFORE DRAWING AN OBJECT
		/************************************************/
		//we bind the buffer for the cube vertices
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
		//we bind the buffer for the cube colors
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBufferPacman);
        gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBufferPacman.itemSize, gl.FLOAT, false, 0, 0);
		//we bind the buffer for the cube vertex indices
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
		/********************************************************************/
		//we update the uniforms for the shaders
        setMatrixUniforms();
		//we call the Draw Call of WebGL to draw the cube
		//Triangles mode
        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		mvPopMatrix();
		
		///////////////////////////////////////////////////////////////////////////////////////
		///////////////////////   GHOST_1    //////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////
		
		//Keyboard controlled cube
		//we use the matrix stack to employ a local transformation to the cube
		mvPushMatrix();
     	//a translation associated with the keyboard
		mat4.translate(mvMatrix, [ghost_1_X*2, 1, -ghost_1_Y*2]);
		/*********************************************/
		//BIND BUFFERS!!!!!!!!!!!!
		//MUST BE DONE ONCE BEFORE DRAWING AN OBJECT
		/************************************************/
		//we bind the buffer for the cube vertices
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
		//we bind the buffer for the cube colors
		if (remainingMoves == 0)
		{
			gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBufferGhost1);
			gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBufferGhost1.itemSize, gl.FLOAT, false, 0, 0);
		}
		else if (remainingMoves > 0)
		{
			gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBufferGhostBlack);
			gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBufferGhostBlack.itemSize, gl.FLOAT, false, 0, 0);
		}
        
		//we bind the buffer for the cube vertex indices
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
		/********************************************************************/
		//we update the uniforms for the shaders
        setMatrixUniforms();
		//we call the Draw Call of WebGL to draw the cube
		//Triangles mode
        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		mvPopMatrix();
		
		///////////////////////////////////////////////////////////////////////////////////////
		///////////////////////   GHOST_2    //////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////
		
		//Keyboard controlled cube
		//we use the matrix stack to employ a local transformation to the cube
		mvPushMatrix();
     	//a translation associated with the keyboard
		mat4.translate(mvMatrix, [ghost_2_X*2, 1, -ghost_2_Y*2]);
		/*********************************************/
		//BIND BUFFERS!!!!!!!!!!!!
		//MUST BE DONE ONCE BEFORE DRAWING AN OBJECT
		/************************************************/
		//we bind the buffer for the cube vertices
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
		//we bind the buffer for the cube colors
		if (remainingMoves == 0)
		{
			gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBufferGhost2);
			gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBufferGhost2.itemSize, gl.FLOAT, false, 0, 0);
		}
		else if (remainingMoves > 0)
		{
			gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBufferGhostBlack);
			gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBufferGhostBlack.itemSize, gl.FLOAT, false, 0, 0);
		}
        
		//we bind the buffer for the cube vertex indices
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
		/********************************************************************/
		//we update the uniforms for the shaders
        setMatrixUniforms();
		//we call the Draw Call of WebGL to draw the cube
		//Triangles mode
        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		mvPopMatrix();
		
		///////////////////////////////////////////////////////////////////////////////////////
		////////////////////////   PLANE   ////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////
		mvPushMatrix();
		mat4.translate(mvMatrix, [6*2, 0.1, 5*2]);
		mat4.scale(mvMatrix, [13.0, 0.1, 10.0 ]);
		/*********************************************/
		//BIND BUFFERS!!!!!!!!!!!!
		//MUST BE DONE ONCE BEFORE DRAWING AN OBJECT
		/************************************************/
		//we bind the buffer for the cube vertices
		gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
		gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
		//we bind the buffer for the cube colors
		gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBufferPlane);
		gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBufferPlane.itemSize, gl.FLOAT, false, 0, 0);
		//we bind the buffer for the cube vertex indices
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
		/********************************************************************/
		setMatrixUniforms();
		gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		mvPopMatrix();
		
		///////////////////////////////////////////////////////////////////////////////////////
		////////////////////////   WALL    ////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////
		for (var objZ = 0; objZ <= 10; objZ++)
		{	
			for (var objX = 0; objX <= 12; objX++)
			{
				if (objType[objZ][objX] == 1)
				{
					mvPushMatrix();
					mat4.translate(mvMatrix, [objX*2, 0.5, objZ*2]);
					mat4.scale(mvMatrix, [1.0, 0.5, 1.0 ]);
					/*********************************************/
					//BIND BUFFERS!!!!!!!!!!!!
					//MUST BE DONE ONCE BEFORE DRAWING AN OBJECT
					/************************************************/
					//we bind the buffer for the cube vertices
					gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
					gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
					//we bind the buffer for the cube colors
					gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
					gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
					//we bind the buffer for the cube vertex indices
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
					/********************************************************************/
					setMatrixUniforms();
					gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
					mvPopMatrix();
				}
				else if (objType[objZ][objX] == 2)
				{	
					mvPushMatrix();
					mat4.translate(mvMatrix, [objX*2, 0.5, objZ*2]);
					mat4.scale(mvMatrix, [0.2, 0.2, 0.2 ]);
					mat4.rotate(mvMatrix, degToRad(rCube), [1, 1, 1]);
					/*********************************************/
					//BIND BUFFERS!!!!!!!!!!!!
					//MUST BE DONE ONCE BEFORE DRAWING AN OBJECT
					/************************************************/
					//we bind the buffer for the cube vertices
					gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
					gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
					//we bind the buffer for the cube colors
					gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBufferPoint);
					gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBufferPoint.itemSize, gl.FLOAT, false, 0, 0);
					//we bind the buffer for the cube vertex indices
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
					/********************************************************************/
					setMatrixUniforms();
					gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
					mvPopMatrix();
				}
				else if (objType[objZ][objX] == 3)
				{	
					mvPushMatrix();
					mat4.translate(mvMatrix, [objX*2, 0.5, objZ*2]);
					mat4.scale(mvMatrix, [0.45, 0.45, 0.45 ]);
					mat4.rotate(mvMatrix, degToRad(rCube), [1, 1, 1]);
					/*********************************************/
					//BIND BUFFERS!!!!!!!!!!!!
					//MUST BE DONE ONCE BEFORE DRAWING AN OBJECT
					/************************************************/
					//we bind the buffer for the cube vertices
					gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
					gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
					//we bind the buffer for the cube colors
					gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBufferPoint);
					gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBufferPoint.itemSize, gl.FLOAT, false, 0, 0);
					//we bind the buffer for the cube vertex indices
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
					/********************************************************************/
					setMatrixUniforms();
					gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
					mvPopMatrix();
				}
				else if (objType[objZ][objX] == 0) 
				{
					
				}
				
			}
		}
		
    }

	//animation parameter
    var lastTime = 0;

	var counter = 0.0;
	//Animate function
    function animate() {
        var timeNow = new Date().getTime();
        if (lastTime != 0) {
            var elapsed = timeNow - lastTime;

			//adjust a constant rotation speed independently of platform/framerate
            rCube -= (75 * elapsed) / 1000.0;
			
			counter += elapsed;
			if (counter > 1000.0){
				movDirection = !movDirection;
				counter = 0;
				}
			if (movDirection)
				swinging += (1 * elapsed) / 1000.0;
			else 
				swinging -= (1 * elapsed) / 1000.0;
				
			
        }
        lastTime = timeNow;
    }


	//this is the requestAnimFrame callback
	//For every tick, request another frame
	//handle keyboard, draw the scene, animate (update animation variebles) and continue
    function tick() {
        requestAnimFrame(tick);
		handleKeys();
		if (gameStatus == 1)
		{
			want();
			direction();
			moveGhost();
			check();
			
			drawScene();
			animate();
		}
		
				
    }

	//Entry point of the WebGL context
	function webGLStart() {
		intro.play();
        var canvas = document.getElementById("TUCWebGL");
        
		//Functions for initialization
		//Check above
		initGL(canvas);
        initShaders()
        initBuffers();

		//Background Color: Color assigned for all pixels with no corresponding fragments
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
		
		//Enable z-buffer for depth sorting
        gl.enable(gl.DEPTH_TEST);

		//define the keyboard handlers
		document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;
		
		//the first tick of our application
        tick();
    }
//end of Javascript
</script>

</head>

<!-- HMTL for the canvas element-->
<body onload="webGLStart();" style="background-color: black;"> <!-- calls the entry point of our application -->
	
	<div align="center">
		<img src="./media/img/logo.gif" style="width:300px; height:150px;"/>
		<div id="WelcomeScreen" style="display:block;color:white; width:500px; height:450px; border-style: solid; border-width:5px; border-radius: 25px; margin:0 auto;">
			
			<br/><br/><br/><span style="font-size:25px;"><u>INSTRUCTIONS</u>: <br/>1. USE THE ARROWS TO MOVE THE PACMAN<br/>2. TRY TO EAT ALL THE PELLETS<br/>3. AVOID THE GHOSTS<br/>4. THERE ARE TWO LEVELS<br/>5. PRESS NUMBER 1 OR 2 TO CHANGE CAMERA</span><br/><br/><br/><br/><br/><br/>
			
			<span style="font-size:35px;color:yellow;">PRESS SPACE TO START!</span>
			
		</div>
		<div id="WinnerScreen" style="display:none;color:white; width:500px; height:450px; border-style: solid; border-width:5px; border-radius: 25px; margin:0 auto;">
			
			<br/><br/><br/><br/><br/><br/>
			<span style="font-size:70px;color:yellow;">YOU WON!</span><br/><br/>
			<span style="font-size:45px;color:yellow;">Press F5 to play again...</span>
			
		</div>
	</div>
	
	<div align="center">
		<canvas id="TUCWebGL" style="border: none;display:none;" width="1024" height="450"></canvas>
	</div>
    


</body></html>